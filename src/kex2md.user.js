// ==UserScript==
// @name         kex2md
// @namespace    http://tampermonkey.net/
// @version      0.1
// @description  Format KaTeX Code generated by GPT into Markdown-compatible LaTeX
// @author       Pachakutiq
// @match        https://chatgpt.com/*
// @grant        none
// ==/UserScript==


(function() {
    'use strict';

    // Selector for the existing Copy buttons
    const copyButtonSelector = 'button.rounded-lg.text-token-text-secondary.hover\\:bg-token-main-surface-secondary[aria-label="Copy"][data-testid="copy-turn-action-button"]';

    function addFormatButton(copyButton) {
        // Check if the Format KaTeX button is already added
        if (copyButton.nextSibling && copyButton.nextSibling.classList.contains('format-katex-button')) {
            return;
        }

        // Create the Format KaTeX button
        const formatButton = document.createElement('button');
        formatButton.textContent = 'Copy md';
        formatButton.className = 'rounded-lg text-token-text-secondary hover:bg-token-main-surface-secondary format-katex-button';
        formatButton.style.marginLeft = '5px';

        // Add click event listener
        formatButton.addEventListener('click', async function() {
            // Simulate click on the corresponding Copy button
            copyButton.click();

            // Wait a bit for the clipboard to update
            await new Promise(resolve => setTimeout(resolve, 100));

            // Read text from clipboard
            let text = '';
            try {
                text = await navigator.clipboard.readText();
            } catch (err) {
                console.error('Failed to read clipboard contents: ', err);
                alert('Failed to read clipboard contents. Please ensure the browser has permissions to access the clipboard.');
                return;
            }

            // Perform replacements
            text = formatKaTeX(text);

            // Save modified text to clipboard
            try {
                await navigator.clipboard.writeText(text);
                // alert('Formatted KaTeX copied to clipboard.');
            } catch (err) {
                console.error('Failed to write to clipboard: ', err);
                // alert('Failed to write to clipboard. Please ensure the browser has permissions to access the clipboard.');
            }
        });

        // Insert the Format KaTeX button after the Copy button
        copyButton.parentNode.insertBefore(formatButton, copyButton.nextSibling);
    }

    // Observe the body for added nodes
    const observer = new MutationObserver(mutations => {
        mutations.forEach(mutation => {
            if (mutation.addedNodes.length) {
                mutation.addedNodes.forEach(node => {
                    if (node.nodeType === 1) {
                        // Check if the node is a Copy button
                        if (node.matches(copyButtonSelector)) {
                            addFormatButton(node);
                        } else {
                            // Check if the node contains Copy buttons
                            const copyButtons = node.querySelectorAll(copyButtonSelector);
                            copyButtons.forEach(addFormatButton);
                        }
                    }
                });
            }
        });
    });

    // Function to format copied text
    function formatKaTeX(text) {
        let formattedText = text;
        formattedText = formattedText.replace(/\\\( /g, '$').replace(/ \\\)/g, '$');
        formattedText = formattedText.replace(/\\\(/g, '$').replace(/\\\)/g, '$');
        formattedText = formattedText.replace(/\\\[ /g, '$$').replace(/ \\\]/g, '$$');
        formattedText = formattedText.replace(/\\\[/g, '$$').replace(/\\\]/g, '$$');

        // Additional formatting step for every line
        formattedText = formattedText.split('\n').map(line => {
            if (line.startsWith('$') && line.endsWith('$') && line.indexOf('$', 1) === line.length - 1) {
                return `$$\n${line.slice(1, -1)}\n$$`;
            }
            return line;
        }).join('\n');

        // Remove empty line before $$
        formattedText = formattedText.replace(/\n+(\$\$)/g, '\n$1');

        return formattedText;
    }

    observer.observe(document.body, { childList: true, subtree: true });

    // Initial setup in case buttons are already present
    document.querySelectorAll(copyButtonSelector).forEach(addFormatButton);

})();
